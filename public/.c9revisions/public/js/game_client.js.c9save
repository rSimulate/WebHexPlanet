{"ts":1361475571803,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":["rex.whitten@acm.org"],"silentsave":false,"ts":1361490009595,"patch":[[{"diffs":[[1,"// Game Client\n// scene_url = this url will load the starSystemObjects from a Url. \nvar Client = function (scene_url) {\n    var self = this;\n\t// Attributes\n\tself.stats = {};\n\tself.scene = new THREE.Scene();\n\tself.renderer = {};\n\tself.composer = {};\n\tself.meshes = [];\n\tself.camera = {};\n\tself.cameraControl = {};\n\tself.gui = {};\n\tself.skymesh = {};\n\tself.SceneUrl = scene_url; // For now some arbitrary value\n\tself.StarSystem = {};\n\t\n\t// Functions \n\tself.drawSkyBox = function()  {\n\t\t\tvar stargeometry = new THREE.IcosahedronGeometry(5000 , 2);\n\t\t\tvar starmaterial\t= new THREE.MeshBasicMaterial({\n\t\t\t\tmap: THREE.ImageUtils.loadTexture(\"images/MilkyWay.jpg\"),\n\t\t\t\tside: THREE.BackSide,\n\t\t\t\t} );\n\t\t\tvar starmesh\t= new THREE.Mesh( stargeometry, starmaterial ); \n\t\t\tself.scene.add( starmesh );\n\t\t\t\n\t\t\treturn starmesh;\n\t;}\n\t\n\tself.lights = function() {\n\t\t\t// lens flares\n\t\t\tvar textureFlare0 = THREE.ImageUtils.loadTexture( \"images/lensflare/lensflare0.png\" );\n\t\t\tvar textureFlare2 = THREE.ImageUtils.loadTexture( \"images/lensflare/lensflare2.png\" );\n\t\t\tvar textureFlare3 = THREE.ImageUtils.loadTexture( \"images/lensflare/lensflare3.png\" );\n\t\t\taddLight( 0.995, 0.025, 0.99, -500, 0, -1000 );\n\t}\n\t\n\tself.addLight = function( h, s, v, x, y, z ) {\n\n\t\t\t\tvar light = new THREE.PointLight( 0xffffff, 1.5, 4500 );\n\t\t\t\tlight.color.setHSL( h, s, v );\n\t\t\t\tlight.position.set( x, y, z );\n\t\t\t\tself.scene.add( light );\n\n\t\t\t\tvar flareColor = new THREE.Color( 0xffffff );\n\t\t\t\tflareColor.setHSL( h, s - 0.5, v + 0.5 );\n\n\t\t\t\tvar lensFlare = new THREE.LensFlare( textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor );\n\n\t\t\t\tlensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );\n\t\t\t\tlensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );\n\t\t\t\tlensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );\n\n\t\t\t\tlensFlare.add( textureFlare3, 60, 0.6, THREE.AdditiveBlending );\n\t\t\t\tlensFlare.add( textureFlare3, 70, 0.7, THREE.AdditiveBlending );\n\t\t\t\tlensFlare.add( textureFlare3, 120, 0.9, THREE.AdditiveBlending );\n\t\t\t\tlensFlare.add( textureFlare3, 70, 1.0, THREE.AdditiveBlending );\n\n\t\t\t\tlensFlare.customUpdateCallback = function lensFlareUpdateCallback( object ) {\n\n\t\t\t\t\tvar f, fl = object.lensFlares.length;\n\t\t\t\t\tvar flare;\n\t\t\t\t\tvar vecX = -object.positionScreen.x * 2;\n\t\t\t\t\tvar vecY = -object.positionScreen.y * 2;\n\n\n\t\t\t\t\tfor( f = 0; f < fl; f++ ) {\n\n\t\t\t\t\t\t   flare = object.lensFlares[ f ];\n\n\t\t\t\t\t\t   flare.x = object.positionScreen.x + vecX * flare.distance;\n\t\t\t\t\t\t   flare.y = object.positionScreen.y + vecY * flare.distance;\n\n\t\t\t\t\t\t   flare.rotation = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.lensFlares[ 2 ].y += 0.025;\n\t\t\t\t\tobject.lensFlares[ 3 ].rotation = object.positionScreen.x * 0.5 + THREE.Math.degToRad( 45 );\n\n\t\t\t\t}\n\t\t\t\tlensFlare.position = light.position;\n\n\t\t\t\tself.scene.add( lensFlare );\n\n\t}\t\t\n\t\n\tself.setHexUVs = function(geometry){\n\t\t\tfor(var f in geometry.faceVertexUvs[0]){\n\t\t\t  \tvar uvs = geometry.faceVertexUvs[0][f];\n\t\t\t  \tuvs[0] = new THREE.Vector2(0.20, 0.73);\n\t\t\t  \tuvs[1] = new THREE.Vector2(0.51, 0.15);\n\t\t\t  \tuvs[2] = new THREE.Vector2(0.78, 0.70);\n\t\t\t}\n\t};\n\t\n\tself.Init = function () {\n\t\tif( Detector.webgl ){\n\t\t\t\tself.renderer = new THREE.WebGLRenderer({\n\t\t\t\t\tantialias\t\t: true,\t// to get smoother output\n\t\t\t\t\tpreserveDrawingBuffer\t: true\t// to allow screenshot\n\t\t\t\t});\n\t\t\t\tself.rendererrenderer.setClearColorHex( 0xBBBBBB, 1 );\n\t\t\t}else{\n\t\t\t\tDetector.addGetWebGLMessage();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tself.rendererrenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tdocument.getElementById('container').appendChild(renderer.domElement);\n\n\t\t\t/// Load the Scene from the url \n\t\t\tself.StarSystem = self.GetSceneFromServer();\n\t\t\t\n\t\t\t// Build the star sytem objects into the Scene\n\t\t\t\n\t\t\t\n\t\t\tself.stats = new Stats();\n\t\t\tself.stats.domElement.style.position\t= 'absolute';\n\t\t\tself.stats.domElement.style.bottom\t= '0px';\n\t\t\tdocument.body.appendChild( stats.domElement );\n\t\t\t\n\t\t\t// create a scene\n\t\t\t// put a camera in the scene\n\t\t\tself.camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, .01, 50000);\n\t\t\tself.camera.position.set(0, 0, 15);\n\t\t\tself.scene.add(camera);\n\n\t\t\t// create a camera contol\n\t\t\tself.cameraControls\t= new THREE.OrbitControls( camera )\n\n\t\t\t// transparently support window resize\n\t\t\tTHREEx.WindowResize.bind(renderer, camera);\n\t\t\t// allow 'p' to make screenshot\n\t\t\tTHREEx.Screenshot.bindKey(renderer);\n\t\t\t// allow 'f' to go fullscreen where this feature is supported\n\t\t\tif( THREEx.FullScreen.available() ){\n\t\t\t\tTHREEx.FullScreen.bindKey();\t\t\n\t\t\t\tdocument.getElementById('inlineDoc').innerHTML\t+= \"- <i>f</i> for fullscreen\";\n\t\t\t}\n\t\t\t\n\t\t\t// other functions \n\t\t\tskymesh = drawSkyBox();\n\t\t\tlights();\n\n\t};\n\t\n\tself.GetSceneFromServer = function() {\n\t\t// TODO: Write ajax function to get JSON StarSystem data until then manually build your scene here. The Generator would build these, and then you would get them back from the server\n\t\t\n\t\tvar starSystemData = new StarSystemData(0,2000,200);\n\t\t// Add planets \n\t\tvar planetData = new PlanetData(1,100);\n\t\t// Add moons to planets \n\t\tvar moonData = new MoonData(1,20);\n\t\tplanetData.Moons.push(moonData);\n\t\t// Add Asteroids \n\t\t\n\t\tself.StarSystem = new StarSystemObject(starSystemData);\n        return starSystemData;\n\t};\n\t\n\tself.render = function (){\n\t\t\t// variable which is increase by Math.PI every seconds - usefull for animation\n\t\t\tvar PIseconds\t= Date.now() * Math.PI;\n\t\t\tvar time = Date.now() / 50;\n\t\t\tvar semimajoraxis = 7;    \t\t// Turn into parameter\n\t\t\tvar eccentricity = 0.0549; \t\t// Turn into parameter\n\t\t\tvar angularvelocity = 0.03;\t\t// Turn into paratmeter\n\t\t\tvar orbitphase = angularvelocity * time;\n\t\t\tvar radius = semimajoraxis * ((1.0 - eccentricity^2)/(1.0 + eccentricity * Math.cos(orbitphase)));\n\t\t\tvar inclination = 6.0 ;\n\t\t\tvar incRadian = (inclination / 180.0) * Math.PI;\n\t\t\tvar maxH = 2;\n\t\t\tvar height = maxH * Math.cos(incRadian) * Math.sin(orbitphase);\n\t\t\tvar rotationspeed = 0.02; //need to study up on this relation to orbit and mass. \n\t\t\t\t\t\t\n\t\t\t//moonmesh.rotation.y += rotationspeed;\t// Moon rotation\n\t\t\t//Moon's orbit\n\t\t\t//moonmesh.position.x = radius * Math.cos(orbitphase);\n\t\t\t//moonmesh.position.z = radius * Math.sin(orbitphase);\n\t\t\t//moonmesh.position.y = height;\n\t\t\t\n\t\t\t//Planet Rotation\n\t\t\t//mesh.rotation.y += 0.01;\n\t\t\t\n\t\t\t// update camera controls\n\t\t\tself.cameraControls.update();\n\n\t\t\t// animation of all objects\n\t\t\t// Update all meshes \n\t\t\tfor(var mesh_index in self.meshes){\n\t\t\t\tvar current_mesh = self.meshes[mesh_index];\n\t\t\t\tcurrent_mesh.Update(); // all of vour gamespace  objects like Planet nad Moon will need an update function. this is only logic that update the object's data NOT for the rendere\n\t\t\t\t// Update hte mesh to the render, I am reading up on how to basically do this ...\n\t\t\t\tself.scene.updateMesh (current_mesh); \n                // Or if we even need to? will THREE.js maintian a pointer?\n\t\t\t};\n\n\t\t\tself.skymesh.position = camera.position;\n\t\t\t// actually render the scene\n\t\t\tself.renderer.render( scene, camera );\n\t\t}\n\t\n\tself.animate = function() {\n\t\t\t// loop on request animation loop\n\t\t\t// - it has to be at the begining of the function\n\t\t\t// - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\t\t\trequestAnimationFrame( animate );\n\t\t\t\n\t\t\t// do the render\n\t\t\tself.render();\n\n\t\t\t// update stats\n\t\t\tself.stats.update();\n\t};\n\t\n\treturn self;\n};"]],"start1":0,"start2":0,"length1":0,"length2":7375}]],"length":7375,"saved":false}
{"ts":1361490247637,"patch":[[{"diffs":[[0,"imation\n"],[1,"            \n            // Some of this stuff needs to be moved to a spaceObject?\n"],[0,"\t\t\tvar P"]],"start1":5342,"start2":5342,"length1":16,"length2":99},{"diffs":[[0,"\t\t\t\n"],[-1,"\t\t\t//moonmesh.rotation.y += rotationspeed;\t// Moon rotation\n\t\t\t//Moon's orbit\n\t\t\t//moonmesh.position.x = radius * Math.cos(orbitphase);\n\t\t\t//moonmesh.position.z = radius * Math.sin(orbitphase);\n\t\t\t//moonmesh.position.y = height;\n\t\t\t\n\t\t\t//Planet Rotation\n\t\t\t//mesh.rotation.y += 0.01;\n\t\t\t\n"],[0,"\t\t\t/"]],"start1":6067,"start2":6067,"length1":296,"length2":8},{"diffs":[[0,"s.update();\n"],[-1,"\n"],[0,"\t\t\t// animat"]],"start1":6121,"start2":6121,"length1":25,"length2":24}]],"length":7169,"saved":false}
